#!/usr/bin/env bash
set -euo pipefail

# === Config you can tweak ===
PKI_DIR="/var/lib/ocserv/pki"       # Easy-RSA PKI home
EASYRSA_DIR="/usr/share/easy-rsa"   # Ubuntu's Easy-RSA scripts
OCSERV_CERT_DIR="/etc/ocserv/certs" # Where ocserv reads certs/keys
OCSERV_CONF="/etc/ocserv/ocserv.conf"
OCSERV_PRE_USER_CONF="/etc/ocserv/config-per-user"
OCSERV_USER="root"
OCSERV_GROUP="root"

# Defaults used on init (can be overridden via flags)
DEFAULT_HOSTNAME=""        # e.g. "vpn.example.com" or "203.0.113.10"
DEFAULT_PORT="443"         # TCP(HTTPS) for ocserv
DEFAULT_NET="10.10.0.0/24" # internal VPN subnet

# === Helpers ===
die() {
  echo "Error: $*" >&2
  exit 1
}
msg() { echo "==> $*"; }
need_root() { [[ $EUID -eq 0 ]] || die "Run as root (sudo)."; }
ensure_dirs() {
  install -d -m 0755 "$1"
  mkdir -p $OCSERV_PRE_USER_CONF
}
ensure_pkgs() {
  msg "Installing required packages (if missing)..."
  apt-get update -y
  DEBIAN_FRONTEND=noninteractive apt-get install -y ocserv easy-rsa openssl
}
ensure_easyrsa() {
  [[ -x "$EASYRSA_DIR/easyrsa" ]] || die "Easy-RSA not found at $EASYRSA_DIR; is easy-rsa installed?"
}
reload_ocserv() {
  systemctl daemon-reload || true
  systemctl enable ocserv || true
  systemctl restart ocserv
  systemctl --no-pager --full status ocserv -l --no-pager || true
}
safe_copy() {
  # safe_copy src dest mode owner group
  local src="$1" dst="$2" mode="$3" owner="$4" group="$5"
  install -D -m "$mode" -o "$owner" -g "$group" "$src" "$dst"
}
ocserv_read_ipv4_network() {
  local conf="${OCSERV_CONF:?OCSERV_CONF is not set}"
  local val

  # Find the first non-comment 'ipv4-network = ...' line and extract the value
  val="$(
    awk '
      BEGIN { IGNORECASE=1 }
      /^[[:space:]]*(#|;)/ { next }           # skip full-line comments
      {
        line=$0
        gsub(/\r/, "", line)                  # strip CR if present
        # match key
        if (line ~ /^[[:space:]]*ipv4-network[[:space:]]*=/) {
          sub(/^[[:space:]]*ipv4-network[[:space:]]*=[[:space:]]*/, "", line)
          sub(/[[:space:]]*(#|;).*$/, "", line)  # strip inline comments
          sub(/[[:space:]]+$/, "", line)         # trim trailing spaces
          print line
          exit
        }
      }
    ' "$conf"
  )"

  if [[ -z "$val" ]]; then
    echo "ipv4-network not found in $conf" >&2
    return 1
  fi

  echo "$val"
}

# Optional helpers if you also want base/prefix split:
# Usage:
#   net="$(ocserv_read_ipv4_network)" || exit 1
#   ocserv_cidr_split "$net" NET_BASE NET_PREFIX
ocserv_cidr_split() {
  local cidr="$1"
  local _out_base="$2"
  local _out_prefix="$3"
  local base prefix
  IFS=/ read -r base prefix <<<"$cidr"
  printf -v "$_out_base" '%s' "$base"
  printf -v "$_out_prefix" '%s' "$prefix"
}

ensure_ocserv_basic_conf() {
  local host="$1" port="$2" net="$3"

  msg "Creating $OCSERV_CONF (new install)..."
  cat >"$OCSERV_CONF" <<EOF
# Minimal ocserv config generated by ocserv-easyrsa.sh
auth = "certificate"
isolate-clients = false

socket-file = /run/ocserv-socket
config-per-user = /etc/ocserv/config-per-user/

tcp-port = $port
#udp-port = $port

run-as-user = nobody
run-as-group = nogroup

# TLS certificates issued by our Easy-RSA CA:
server-cert = $OCSERV_CERT_DIR/server.crt
server-key  = $OCSERV_CERT_DIR/server.key
ca-cert     = $OCSERV_CERT_DIR/ca.crt

# Use Common Name (CN) as username. This avoids DN/OID pitfalls.
cert-user-oid = 2.5.4.3

# Network config
device = vpns
ipv4-network = $net
tunnel-all-dns = true
dns = 1.1.1.1
dns = 9.9.9.9

# Routing
default-domain = $host
route = default # Internet access
try-mtu-discovery = true

# Session / policy basics
cookie-timeout = 300
idle-timeout = 1200
isolate-workers = true
deny-roaming = false

# Limits
max-clients = 128
max-same-clients = 3

# Logging
use-syslog = true
EOF
}

export_p12() {
  local name="$1" outdir="$2" pass="${3:-}"
  local cli_key="$PKI_DIR/pki/private/$name.key"
  local cli_crt="$PKI_DIR/pki/issued/$name.crt"
  local ca_crt="$PKI_DIR/pki/ca.crt"
  [[ -f "$cli_key" && -f "$cli_crt" ]] || die "Client $name not found in PKI."

  ensure_dirs "$outdir"
  local p12="$outdir/${name}.p12"
  if [[ -n "$pass" ]]; then
    # Non-interactive: export password via env
    # shellcheck disable=SC1117
    openssl pkcs12 -export -inkey "$cli_key" -in "$cli_crt" -certfile "$ca_crt" -out "$p12" -passout "pass:$pass"
  else
    openssl pkcs12 -export -inkey "$cli_key" -in "$cli_crt" -certfile "$ca_crt" -out "$p12"
  fi
  chmod 0600 "$p12"
  echo "$p12"
}

print_usage() {
  cat <<'USAGE'
Usage:
  ocserv-easyrsa.sh init --host <FQDN-or-IP> [--port 443] [--net 10.10.0.0/24]
      Install pkgs, initialize Easy-RSA PKI, issue server cert, configure ocserv.

  ocserv-easyrsa.sh add-client <name> [--out /root/clients] [--p12-pass <pass>]
      Issue a client cert+key and export .p12 (with optional password).

  ocserv-easyrsa.sh revoke-client <name>
      Revoke a client cert and build CRL (ocserv will honor it on restart).

  ocserv-easyrsa.sh rotate-server --host <FQDN-or-IP>
      Issue a new server cert (CN/SAN) and reload ocserv.

  ocserv-easyrsa.sh list-clients
      Show issued and revoked certs.

  ocserv-easyrsa.sh export-ca [--out /root/clients]
      Copy ca.crt for distribution.

  ocserv-easyrsa.sh status
      Print ocserv and PKI status.

Examples:
  ocserv-easyrsa.sh init --host vpn.example.com --port 443 --net 10.20.0.0/24
  ocserv-easyrsa.sh add-client alice --out /root/clients
  ocserv-easyrsa.sh add-client bob --p12-pass "StrongPass"
  ocserv-easyrsa.sh rotate-server --host 203.0.113.10
  ocserv-easyrsa.sh revoke-client alice
USAGE
}

# === Subcommands ===

cmd_init() {
  need_root
  ensure_pkgs
  ensure_easyrsa

  local host="$DEFAULT_HOSTNAME"
  local port="$DEFAULT_PORT"
  local net="$DEFAULT_NET"

  while [[ $# -gt 0 ]]; do
    case "$1" in
    --host)
      host="${2:-}"
      shift 2
      ;;
    --port)
      port="${2:-}"
      shift 2
      ;;
    --net)
      net="${2:-}"
      shift 2
      ;;
    *) die "Unknown flag for init: $1" ;;
    esac
  done
  [[ -n "$host" ]] || die "init requires --host <FQDN-or-IP>"

  ensure_dirs "$PKI_DIR"
  ensure_dirs "$OCSERV_CERT_DIR"

  # Initialize PKI if missing
  if [[ ! -d "$PKI_DIR/pki" ]]; then
    msg "Initializing Easy-RSA PKI in $PKI_DIR ..."
    install -d -m 0700 "$PKI_DIR"
    pushd "$PKI_DIR" >/dev/null
    cp -r "$EASYRSA_DIR"/* .
    ./easyrsa --batch init-pki
    # Build CA without passphrase for automation; change if you prefer a pass
    ./easyrsa --batch build-ca nopass
    popd >/dev/null
  else
    msg "PKI already exists at $PKI_DIR; skipping init."
  fi

  # Build server cert (CN = host)
  if [[ ! -f "$PKI_DIR/pki/issued/server.crt" ]]; then
    msg "Issuing server certificate for CN=$host ..."
    pushd "$PKI_DIR" >/dev/null
    # Create a dedicated req name "server"; will produce server.crt/key
    ./easyrsa --batch build-server-full "server" nopass
    popd >/dev/null
  else
    msg "Server certificate already exists; will reuse."
  fi

  # Place certs/keys for ocserv
  safe_copy "$PKI_DIR/pki/issued/server.crt" "$OCSERV_CERT_DIR/server.crt" 0644 "$OCSERV_USER" "$OCSERV_GROUP"
  safe_copy "$PKI_DIR/pki/private/server.key" "$OCSERV_CERT_DIR/server.key" 0600 "$OCSERV_USER" "$OCSERV_GROUP"
  safe_copy "$PKI_DIR/pki/ca.crt" "$OCSERV_CERT_DIR/ca.crt" 0644 "$OCSERV_USER" "$OCSERV_GROUP"

  ensure_ocserv_basic_conf "$host" "$port" "$net"

  # Generate initial CRL so revocation works
  if [[ ! -f "$PKI_DIR/pki/crl.pem" ]]; then
    msg "Generating CRL..."
    pushd "$PKI_DIR" >/dev/null
    ./easyrsa --batch gen-crl
    popd >/dev/null
  fi
  safe_copy "$PKI_DIR/pki/crl.pem" "$OCSERV_CERT_DIR/crl.pem" 0644 "$OCSERV_USER" "$OCSERV_GROUP"

  # Make sure ocserv can find CRL (some builds expect it configured; many auto-detect)
  if ! grep -qE 'crl =' "$OCSERV_CONF" 2>/dev/null; then
    echo "crl = $OCSERV_CERT_DIR/crl.pem" >>"$OCSERV_CONF"
  fi

  msg "Enabling IP forwarding (recommended for routing clients)..."
  sed -ri 's/^#?net.ipv4.ip_forward.*/net.ipv4.ip_forward=1/' /etc/sysctl.conf
  sed -ri 's/^#?net.ipv6.conf.all.forwarding.*/net.ipv6.conf.all.forwarding=1/' /etc/sysctl.conf
  sysctl -p || true

  msg "Init complete. Reloading ocserv..."
  reload_ocserv
  msg "Done. You can now add clients with:  $0 add-client alice --out /root/clients"
}

cmd_add_client() {
  need_root
  local name="${1:-}"
  shift || true
  [[ -n "${name:-}" ]] || die "add-client requires <name>"
  local outdir="/root/clients"
  local p12_pass=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
    --out)
      outdir="${2:-}"
      shift 2
      ;;
    --p12-pass)
      p12_pass="${2:-}"
      shift 2
      ;;
    *) die "Unknown flag for add-client: $1" ;;
    esac
  done

  ensure_easyrsa
  [[ -d "$PKI_DIR/pki" ]] || die "PKI not found. Run: $0 init --host <FQDN-or-IP>"

  msg "Issuing client cert for CN=$name ..."
  pushd "$PKI_DIR" >/dev/null
  if [[ -f "pki/issued/$name.crt" ]]; then
    die "Client '$name' already exists. Use a different name or revoke first."
  fi
  ./easyrsa --batch build-client-full "$name" nopass
  popd >/dev/null

  ip2u32() {
    local a b c d
    IFS=. read -r a b c d <<<"$1"
    printf '%u\n' $(((a << 24) | (b << 16) | (c << 8) | d))
  }

  int2ip() { # $1=uint32
    awk -v n="$1" '
      BEGIN{
        o1=int(n/16777216); n-=o1*16777216
        o2=int(n/65536);    n-=o2*65536
        o3=int(n/256);      n-=o3*256
        o4=n
        printf "%d.%d.%d.%d\n", o1,o2,o3,o4
      }'
  }

  cidr_mask() { # $1=prefixlen -> mask as uint32
    local p="$1"
    # ((0xFFFFFFFF << (32-p))) may overflow signed; mask it back to 32 bits.
    printf '%u\n' $((((0xFFFFFFFF << (32 - p)) & 0xFFFFFFFF)))
  }

  ip_and() {
    local ip_u32 mask_u32
    ip_u32=$(ip2u32 "$1")
    mask_u32=$2
    printf '%u\n' $((ip_u32 & mask_u32))
  }

  # ---- derive network, range, used IPs ----
  net="$(ocserv_read_ipv4_network)" || exit 1
  msg "Net in the configuration is $net"

  ocserv_cidr_split "$net" NET_BASE NET_PREFIX
  msg "NET_BASE is $NET_BASE; NET_PREFIX is $NET_PREFIX"

  MASK_U32=$(cidr_mask "$NET_PREFIX")
  msg "MASK is $MASK_U32"

  NET_U32=$(ip_and "$NET_BASE" "$MASK_U32")
  msg "NET is $MASK_U32"

  BCAST_U32=$((NET_U32 + ((1 << (32 - NET_PREFIX)) - 1)))
  msg "BCAST is $BCAST_U32"

  FIRST_HOST=$((NET_U32 + 1))
  LAST_HOST=$((BCAST_U32 - 1))
  msg "FIRST_HOST is $FIRST_HOST"
  msg "LAST_HOST is $LAST_HOST"

  # collect already assigned IPs (from recursive per-user configs)
  # expected lines like:  ipv4 = 10.10.0.42
  msg "Calculating already used IPs"
  declare -A USED
  while IFS= read -r ip; do
    msg "$ip is already in use"
    [[ -n "$ip" ]] && USED["$ip"]=1
  done < <(find "$OCSERV_PRE_USER_CONF" -type f -print0 |
    xargs -0 grep -hE '^[[:space:]]*ipv4[[:space:]]*=' 2>/dev/null |
    sed -E 's/.*ipv4[[:space:]]*=[[:space:]]*([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+).*/\1/')

  # build candidate pool
  msg "Building a candidate pool"
  CANDIDATES=()
  i=$FIRST_HOST
  while ((i <= LAST_HOST)); do
    ip=$(int2ip "$i")
    last_octet=${ip##*.}

    # Skip if last octet is 1 or 255 (extra safety), and if already used
    if [[ "$last_octet" != "1" && "$last_octet" != "255" && -z "${USED[$ip]+x}" ]]; then
      msg "$ip is a candidate"
      CANDIDATES+=("$ip")
    fi
    ((i++))
  done

  if ((${#CANDIDATES[@]} == 0)); then
    echo "No free IPs left in $net under $OCSERV_PRE_USER_CONF" >&2
    return 1
  fi

  # choose a random free IP
  msg "Choosing a random free IP"
  rand_index=$((RANDOM % ${#CANDIDATES[@]}))
  CHOSEN_IP="${CANDIDATES[$rand_index]}"

  # write per-user config
  mkdir -p "$OCSERV_PRE_USER_CONF"
  cat >"$OCSERV_PRE_USER_CONF/$name" <<EOF
ipv4-network = ${CHOSEN_IP}
ipv4-netmask = 255.255.255.252
EOF

  echo "Assigned ${CHOSEN_IP} to user ${name}"

  # Export .p12 for easy import on Android/Windows/iOS
  local p12
  p12=$(export_p12 "$name" "$outdir" "$p12_pass")
  msg "Client generated:"
  echo "  CRT: $PKI_DIR/pki/issued/$name.crt"
  echo "  KEY: $PKI_DIR/pki/private/$name.key"
  echo "  P12: $p12"
  msg "If clients see 'username not found from DN/OID', we already map CN -> username via cert-user-oid=2.5.4.3."
}

cmd_revoke_client() {
  need_root
  local name="${1:-}"
  shift || true
  [[ -n "${name:-}" ]] || die "revoke-client requires <name>"

  ensure_easyrsa
  [[ -d "$PKI_DIR/pki" ]] || die "PKI not found. Run init first."

  msg "Revoking client '$name' ..."
  pushd "$PKI_DIR" >/dev/null
  ./easyrsa --batch revoke "$name" || die "Revoke failed (does user exist?)"
  ./easyrsa --batch gen-crl
  rm $OCSERV_PRE_USER_CONF/$name
  popd >/dev/null
  safe_copy "$PKI_DIR/pki/crl.pem" "$OCSERV_CERT_DIR/crl.pem" 0644 "$OCSERV_USER" "$OCSERV_GROUP"

  msg "Reloading ocserv to pick up new CRL..."
  reload_ocserv
  msg "Client '$name' revoked."
}

cmd_rotate_server() {
  need_root
  ensure_easyrsa
  [[ -d "$PKI_DIR/pki" ]] || die "PKI not found. Run init first."

  local host=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --host)
      host="${2:-}"
      shift 2
      ;;
    *) die "Unknown flag for rotate-server: $1" ;;
    esac
  done
  [[ -n "$host" ]] || die "rotate-server requires --host <FQDN-or-IP>"

  msg "Rotating server certificate to CN=$host ..."
  pushd "$PKI_DIR" >/dev/null
  # Re-issue "server" identity (overwrites)
  rm -f pki/issued/server.crt pki/private/server.key || true
  ./easyrsa --batch build-server-full "server" nopass
  popd >/dev/null

  safe_copy "$PKI_DIR/pki/issued/server.crt" "$OCSERV_CERT_DIR/server.crt" 0644 "$OCSERV_USER" "$OCSERV_GROUP"
  safe_copy "$PKI_DIR/pki/private/server.key" "$OCSERV_CERT_DIR/server.key" 0600 "$OCSERV_USER" "$OCSERV_GROUP"

  msg "Reloading ocserv..."
  reload_ocserv
  msg "Server certificate rotated."
}

cmd_list_clients() {
  [[ -d "$PKI_DIR/pki" ]] || die "PKI not found."
  echo "Issued client certs:"
  ls -1 "$PKI_DIR/pki/issued/" | sed -n 's/\.crt$//p' || true
  echo
  echo "Revoked (in index):"
  grep -E '^R' "$PKI_DIR/pki/index.txt" 2>/dev/null || echo "(none)"
}

cmd_export_ca() {
  need_root
  local outdir="/root/clients"
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --out)
      outdir="${2:-}"
      shift 2
      ;;
    *) die "Unknown flag for export-ca: $1" ;;
    esac
  done
  [[ -f "$PKI_DIR/pki/ca.crt" ]] || die "CA not found; run init."
  ensure_dirs "$outdir"
  cp -f "$PKI_DIR/pki/ca.crt" "$outdir/ca.crt"
  chmod 0644 "$outdir/ca.crt"
  echo "$outdir/ca.crt"
}

cmd_status() {
  echo "ocserv status:"
  systemctl --no-pager --full status ocserv -l --no-pager || true
  echo
  echo "PKI at: $PKI_DIR"
  [[ -f "$PKI_DIR/pki/ca.crt" ]] && echo "  CA: present" || echo "  CA: MISSING"
  [[ -f "$PKI_DIR/pki/issued/server.crt" ]] && echo "  Server cert: present" || echo "  Server cert: MISSING"
  echo "Clients (issued):"
  ls -1 "$PKI_DIR/pki/issued" 2>/dev/null | sed -n 's/\.crt$//p'
  echo
  echo "CRL: $([[ -f "$PKI_DIR/pki/crl.pem" ]] && echo present || echo MISSING)"
  echo "CRL installed at $OCSERV_CERT_DIR/crl.pem: $([[ -f "$OCSERV_CERT_DIR/crl.pem" ]] && echo present || echo MISSING)"
  echo
  echo "ocserv cert paths (from $OCSERV_CONF):"
  grep -E '^(server-cert|server-key|ca-cert|crl)\s*=' "$OCSERV_CONF" || true
}

# === Dispatch ===
sub="${1:-}"
shift || true
case "${sub:-}" in
init) cmd_init "$@" ;;
add-client) cmd_add_client "$@" ;;
revoke-client) cmd_revoke_client "$@" ;;
rotate-server) cmd_rotate_server "$@" ;;
list-clients) cmd_list_clients "$@" ;;
export-ca) cmd_export_ca "$@" ;;
status) cmd_status "$@" ;;
"" | -h | --help | help) print_usage ;;
*)
  print_usage
  die "Unknown subcommand: $sub"
  ;;
esac
